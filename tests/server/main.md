当然可以，现在我们正式进入**服务端（执行端）测试流程文档**的编写阶段。  
我会按照你之前所有冻结的技术设计（Executor v1.3）来写一份**工程级、可直接用于编写自动化测试脚本的测试流程文档**。

这份文档的目标是：

- 定义**测试范围**
- 定义**测试前置条件**
- 定义**测试流程**
- 定义**测试用例结构**
- 定义**覆盖所有执行端能力的测试矩阵**
- 让任何工程师都能据此编写**自动化测试脚本**

下面是完整文档。

---

# 远程赛车输入控制系统
## 执行端测试流程文档
**Executor Test Process v1.0（用于编写完备测试脚本）**

---

# 1. 文档定位

本测试流程文档用于指导对**执行端（Executor）**进行完整、系统化、可自动化的测试。

测试目标：

- 验证执行端是否严格遵守《Executor Technical Design v1.3》
- 验证执行端在各种输入、时序、异常情况下的行为一致性
- 验证执行端的安全性（无残留输入）
- 验证执行端的兼容性（ViGEmBus、keysender）
- 为自动化测试脚本提供可直接实现的流程

---

# 2. 测试范围（冻结）

执行端测试覆盖以下能力：

| 能力 | 是否测试 |
|---|---|
| WebSocket 接收与解析 | ✔ |
| ControlResultState 校验 | ✔ |
| 状态驱动模型（覆盖式更新） | ✔ |
| 超时清零（500ms） | ✔ |
| 异常清零 | ✔ |
| 键盘输出（keysender） | ✔ |
| 手柄输出（完整 Xbox 通道） | ✔ |
| 清零后无残留输入 | ✔ |
| ACK 生成 | ✔ |
| 调度频率（125Hz） | ✔ |
| 幂等性（重复状态不重复输出） | ✔ |

不测试：

- 前端布局逻辑
- 控制语义生成
- UI 行为
- 游戏响应（属于集成测试）

---

# 3. 测试前置条件

## 3.1 系统依赖

- Windows 10/11
- Node.js ≥ 18
- ViGEmBus 驱动已安装
- `vigemclient` 可正常加载
- `keysender` 可正常调用
- 执行端可启动（无驱动错误）

## 3.2 测试工具

- 自动化 WebSocket 客户端（可用 Node.js 脚本）
- 输入监控工具：
    - **手柄监控**：Gamepad Tester / ViGEmBus Monitor
    - **键盘监控**：Windows Spy / AutoHotKey KeyHistory
- 时间测量工具（用于 RTT 测试）

---

# 4. 测试流程总览

测试流程分为 8 个阶段：

1. **启动阶段测试**
2. **WebSocket 连接测试**
3. **状态更新与覆盖测试**
4. **键盘输出测试**
5. **手柄输出测试（完整 Xbox 通道）**
6. **调度与幂等性测试**
7. **安全回退测试（超时 / 异常 / 断连）**
8. **ACK 与 RTT 测试**

每个阶段包含：

- 测试目标
- 测试步骤
- 预期结果
- 自动化脚本要点

---

# 5. 测试流程（详细）

---

## 5.1 启动阶段测试

### 目标
验证执行端启动时：

- 驱动加载正常
- Adapter 初始化正常
- 无异常清零
- Scheduler 正常运行

### 步骤
1. 启动执行端
2. 观察日志输出
3. 检查虚拟 Xbox 控制器是否成功创建
4. 检查键盘 Adapter 是否加载成功

### 预期结果
- “ViGEmBus connected”
- “X360 controller created”
- “Keyboard adapter ready”
- 无异常日志

---

## 5.2 WebSocket 连接测试

### 目标
验证执行端能正确处理连接、断开、重连。

### 步骤
1. 建立 WebSocket 连接
2. 发送 ping 消息
3. 关闭连接
4. 重连

### 预期结果
- 执行端接受连接
- 断连后立即清零
- 重连后恢复正常

---

## 5.3 状态更新与覆盖测试

### 目标
验证状态驱动模型：

- 新状态覆盖旧状态
- 无事件残留
- 缺失字段等价于零状态

### 步骤
1. 发送状态 A（键盘 W）
2. 发送状态 B（键盘 A）
3. 发送状态 C（空状态）

### 预期结果
- A → W 按下
- B → W 释放，A 按下
- C → 所有按键释放

---

## 5.4 键盘输出测试（keysender）

### 目标
验证键盘输出行为：

- KeyDown / KeyUp 正确
- 差分逻辑正确
- 清零正确

### 测试用例

| 用例 | 输入 | 预期输出 |
|---|---|---|
| K1 | pressedKeys=["W"] | W 按下 |
| K2 | pressedKeys=["W","A"] | A 按下（W 保持） |
| K3 | pressedKeys=["A"] | W 释放 |
| K4 | pressedKeys=[] | 所有释放 |
| K5 | 重复发送同一状态 | 无重复 KeyDown |

---

## 5.5 手柄输出测试（完整 Xbox 通道）

### 目标
验证所有 Xbox 通道均可正确输出。

### 测试矩阵（冻结）

#### 轴（Axes）

| 用例 | 输入 | 预期 |
|---|---|---|
| AX1 | LX=1.0 | 左摇杆右满 |
| AX2 | LX=-1.0 | 左摇杆左满 |
| AX3 | LY=1.0 | 左摇杆下满 |
| AX4 | RX=0.5 | 右摇杆右半 |
| AX5 | 越界值（1.5） | clamp 为 1.0 |

#### 扳机（Triggers）

| 用例 | 输入 | 预期 |
|---|---|---|
| TR1 | LT=1.0 | 左扳机满压 |
| TR2 | RT=0.3 | 右扳机 30% |
| TR3 | 越界值（-0.2） | clamp 为 0.0 |

#### 按钮（Buttons）

| 用例 | 输入 | 预期 |
|---|---|---|
| BT1 | A=true | A 按下 |
| BT2 | LB=true | LB 按下 |
| BT3 | DPAD_UP=true | DPad Up 按下 |
| BT4 | 所有 false | 所有按钮释放 |

---

## 5.6 调度与幂等性测试

### 目标
验证：

- 125Hz 调度正常
- 重复状态不重复输出
- 状态变化立即生效

### 步骤
1. 发送状态 A
2. 连续 100 tick 不变
3. 发送状态 B

### 预期
- Adapter 不重复发送相同 KeyDown
- 手柄状态每 tick 写入，但值不变
- 状态 B 立即覆盖

---

## 5.7 安全回退测试（超时 / 异常 / 断连）

### 目标
验证执行端的安全性。

### 测试用例

| 用例 | 行为 | 预期 |
|---|---|---|
| S1 | 超过 500ms 无新状态 | 自动清零 |
| S2 | WebSocket 断连 | 立即清零 |
| S3 | Adapter 抛异常 | 立即清零 |
| S4 | 非法状态（结构错误） | 清零 + 拒绝状态 |

---

## 5.8 ACK 与 RTT 测试

### 目标
验证：

- ACK 在 apply 成功后发送
- RTT 计算正确

### 步骤
1. 发送带 timestamp 的状态
2. 等待 ACK
3. 计算 RTT

### 预期
- ACK.sequence == 输入 sequence
- RTT > 0 且稳定

---

# 6. 自动化测试脚本结构（建议）

```
tests/
  common/
    wsClient.js
    time.js
    assert.js
  cases/
    startup.test.js
    websocket.test.js
    keyboard.test.js
    gamepad_axes.test.js
    gamepad_buttons.test.js
    gamepad_triggers.test.js
    scheduler.test.js
    safety.test.js
    ack.test.js
  runner/
    runAll.js
```

---

# 7. 测试覆盖率要求（冻结）

- **功能覆盖率：100%**
- **手柄通道覆盖率：100%（所有 Xbox 通道）**
- **键盘按键覆盖率：至少 10 个常用键**
- **异常路径覆盖率：100%**
- **清零路径覆盖率：100%**

---

# 8. 文档状态

**Executor Test Process v1.0 · 冻结版**

---

如果你愿意，我可以继续输出：

- **每个测试用例的自动化脚本模板**
- **完整 Node.js 测试框架（Mocha/Jest）结构**
- **执行端集成测试（含虚拟设备监控）**

你现在的执行端已经具备完整的测试闭环，我们可以直接进入脚本编写阶段。
