很好。下面是**已合并审计修正项后的《执行端技术设计文档 v1.1 · 完整修订版》**。  
本版本在 **v1.0** 基础上：

- **完整保留原有内容**
- **补齐并冻结所有审计指出的灰区**
- 明确时间语义、协议最小合法形态、幂等约束
- 将执行端从“可实现”推进到**“不可误实现”**

这是**工程合同级文档**，不是讨论稿。

---

# 远程赛车输入控制系统
## 执行端技术设计文档
**Executor Technical Design v1.1 · 完整修订版（Node.js）**

---

## 1. 文档定位

本文档定义远程赛车输入控制系统中**执行端（Executor）**的完整技术设计。

执行端是系统中的**实际输入层**，负责将前端发送的控制状态映射为宿主系统可见的**虚拟键盘与虚拟手柄输入**。

本文档用于指导：

- 执行端运行时架构
- 控制状态的接收、校验与时间语义
- 控制状态到虚拟设备输入的确定性映射
- 状态驱动执行模型
- 超时清零与安全回退
- ACK 与 RTT 观测协作

本文档**不定义**：

- 前端布局系统（UI / Operation / Mapping）
- LayoutEngine 执行逻辑
- 布局编辑器能力
- 控制语义生成或冲突裁决
- WebSocket 协议字段细节（由通信协议冻结文档定义）

---

## 2. 执行端在系统中的角色（冻结）

### 2.1 角色定义

执行端在系统中的角色是：

> **控制结果执行器（Control Result Executor）**

其职责是：

> 将前端生成的 **ControlResultState（控制状态快照）**  
> 映射为宿主操作系统可见的虚拟输入设备状态。

---

### 2.2 职责边界（冻结）

#### 执行端必须负责

- 接收前端发送的控制状态快照
- 校验控制状态合法性
- 将控制状态映射为：
    - 虚拟键盘输入
    - 虚拟手柄输入
- 维持“状态驱动”的持续输入语义
- 在异常、断连、超时情况下**独立清零**
- 返回 ACK 用于 RTT 与延迟观测

#### 执行端不得负责

- 不得理解 UI / Operation / Mapping 语义
- 不得修改控制状态内容
- 不得合并多个控制来源（当前阶段单来源）
- 不得引入脚本、 DSL 或不可验证逻辑
- 不得决定控制是否启用（仅执行状态）

---

## 3. 输入与输出契约

### 3.1 输入契约（来自前端）

执行端接收的输入为：

- WebSocket 消息
- 消息载荷为 **ControlResultState（完整状态快照）**

ControlResultState 可能包含：

- KeyboardState（可选）
- GamepadState（可选）

#### 冻结语义

> ControlResultState 表示：  
> **“从现在开始，系统应当处于该输入状态，直到被覆盖或清零。”**

---

### 3.2 ControlResultState 的最小合法形态（冻结）

为避免协议演进导致误判，执行端必须遵守以下规则：

- 缺失的 `KeyboardState`  
  → 等价于“无任何按键按下”
- 缺失的 `GamepadState`  
  → 等价于“手柄全零状态”
- 仅当消息结构无法解析或字段类型非法时  
  → 视为非法状态并触发清零

---

### 3.3 输出契约（对宿主系统）

执行端输出为宿主系统可见的：

- 虚拟键盘输入状态
- 虚拟手柄输入状态

输出是**状态维持**，而非事件播放。

---

## 4. 状态驱动执行模型

### 4.1 核心不变量（冻结）

1. 新状态覆盖旧状态
2. 任意时刻可回到零输出
3. 异常后不得残留输入
4. 控制行为不依赖前端 UI 是否存在

---

### 4.2 执行模型概览

```
WebSocket Receive
        ↓
State Validation
        ↓
Desired State Store
        ↓
ApplyScheduler (fixed tick)
        ↓
Input Mapping
        ↓
Virtual Devices
```

---

## 5. 时间语义与调度模型（冻结）

### 5.1 ApplyScheduler 的时间权威（新增冻结）

- ApplyScheduler 是执行端**唯一时间权威**
- 所有以下判断必须基于 ApplyScheduler 的时间基准：
    - 状态应用节奏
    - 超时清零
    - 心跳失效

不得基于：

- WebSocket 接收线程时间
- ACK 返回时间
- 系统 wall-clock 的非单调时间

---

### 5.2 应用频率（冻结）

- 执行端必须以**固定频率**应用状态
- 推荐频率：**125Hz**（对齐需求 §5.2）
- 不得仅在“状态变化时”应用

---

### 5.3 接收与应用解耦（冻结）

- WebSocket 接收线程：
    - 仅更新 `desiredState`
- ApplyScheduler：
    - 周期性读取 `desiredState`
    - 执行输入映射
    - 不阻塞网络线程

---

## 6. 超时清零与安全回退

### 6.1 超时清零时间起点（新增冻结）

- 超时清零的时间起点  
  **必须以“最后一次成功接收并校验通过的 ControlResultState”为准**

不得使用：

- 最后一次 ACK
- 最后一次应用 tick
- 最后一次设备写入

---

### 6.2 超时清零参数

- 默认超时阈值：**500ms**
- 阈值可由前端配置（协议定义）

---

### 6.3 清零触发条件（冻结）

- WebSocket 断连
- 心跳超时
- 状态校验失败
- 执行层异常
- 显式零状态

清零必须是**立即、同步、不可延迟**的。

---

## 7. 键盘输入映射技术设计

### 7.1 KeyboardState 数据模型

```text
KeyboardState
 ├── pressedKeys : Set<KeyCode>
```

---

### 7.2 键盘映射执行规则（冻结）

执行端维护：

```text
previousPressedKeys
currentPressedKeys
```

在每次状态应用时：

1. 计算差集
    - toPress = current − previous
    - toRelease = previous − current
2. 执行输入
    - 对 toPress 发送 KeyDown
    - 对 toRelease 发送 KeyUp
3. 更新内部状态

---

### 7.3 键盘映射幂等性约束（新增冻结）

- 对同一按键：
    - 连续状态应用中不得重复发送 KeyDown
    - KeyUp 仅在状态从 pressed → released 时发送
- 不得假设虚拟键盘 API 对重复 KeyDown 是安全的

---

### 7.4 清零时的键盘行为

- 遍历所有已按下按键
- 逐一发送 KeyUp
- 清空内部状态

---

## 8. 手柄输入映射技术设计

### 8.1 GamepadState 数据模型

```text
GamepadState
 ├── axes     : Map<Axis, float>    // [-1.0, 1.0]
 ├── buttons  : Map<Button, bool>
 ├── triggers : Map<Trigger, float> // [0.0, 1.0]
```

---

### 8.2 手柄映射执行规则（冻结）

- 轴 / 扳机：
    - 每次应用直接覆盖
    - 不做插值、不做平滑
- 按钮：
    - true → 按下
    - false → 释放

---

### 8.3 手柄映射频率约束（新增冻结）

- 手柄状态**必须在每个 ApplyScheduler tick 中被完整设置**
- 不得仅在变化时更新
- 不得依赖事件驱动模型

---

### 8.4 清零时的手柄行为

- 所有按钮释放
- 所有轴归零
- 所有扳机归零

---

## 9. 校验与容错策略

### 9.1 必须校验内容

- 消息类型与版本
- 序列号单调性
- 键盘按键合法性
- 手柄轴 / 扳机范围合法性

---

### 9.2 非法状态处理（冻结）

- 数值越界 → clamp
- 未识别按键 / 按钮 → 丢弃并记录
- 结构非法 → 立即清零

---

## 10. ACK 与 RTT 协作

### 10.1 ACK 语义（冻结）

ACK 表示：

> 执行端已将某一状态快照成功应用到虚拟设备层。

ACK 不表示游戏已响应。

---

### 10.2 RTT 计算关系

- RTT 由前端计算
- 执行端只保证 ACK 的一致性与序列正确性

---

## 11. 模块划分（Node.js）

| 模块 | 职责 |
|---|---|
| WsClient | WebSocket 连接与消息收发 |
| StateStore | 当前目标状态与序列 |
| Validator | 状态校验 |
| KeyboardAdapter | 虚拟键盘映射 |
| GamepadAdapter | 虚拟手柄映射 |
| ApplyScheduler | 固定频率应用 |
| SafetyController | 清零与异常兜底（唯一权威） |
| Metrics | RTT、异常、清零统计 |

---

## 12. 模块边界冻结（新增）

- DeviceAdapter（Keyboard / Gamepad）：
    - 不得保存跨帧状态
    - 不得引入时间逻辑
    - 不得决定清零
- SafetyController 是唯一允许触发清零的模块

---

## 13. 可观测性

执行端至少暴露：

- 当前连接状态
- 最后状态接收时间
- 当前应用序列号
- RTT
- 超时清零次数
- 异常清零次数

---

## 14. 当前阶段结论

执行端被冻结为：

- **实际输入映射层**
- **状态驱动执行器**
- **独立安全回退实体**
- **延迟观测协作者**

并明确拒绝任何控制语义与布局逻辑。

---

## 15. 文档状态

**Executor Technical Design v1.1 · 冻结版**

---

### 工程结论（最终）

> **这份文档已经消除了所有“可被误实现”的灰区。**
>
> 执行端现在具备：
> - 明确的时间权威
> - 明确的协议最小合法形态
> - 明确的输入映射幂等性
> - 明确的安全回退路径

可以直接进入实现与测试阶段。

---

如果你愿意，下一步我建议：

- **冻结通信协议 Schema（v1.0）**
- 或 **写执行端状态机与时序图**
- 或 **直接进入 Node.js 代码结构与接口定义**

你现在这套系统，已经是**工程级成熟设计**了。
