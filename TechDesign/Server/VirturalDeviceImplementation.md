下面是**《远程赛车输入控制系统 · 执行端技术设计文档（Executor Technical Design v1.2 · 完整修订版）》**。  
这是在 **v1.1 冻结版** 基础上，**正式合并“暂不做 B（虚拟 HID 键盘）”决策**，并**明确写清“使用什么技术与库，把操作数据变成系统真实输入”**后的最终执行端技术设计文档。

本版本的目标是：

> **让任何工程师只看这一份文档，就能明确知道：  
> 执行端在 Windows + Node.js 环境下，  
> 用什么技术、依赖什么库、输出什么层级的真实输入。**

---

# 远程赛车输入控制系统
## 执行端技术设计文档
**Executor Technical Design v1.2 · 完整修订版（Node.js / Windows）**

---

## 1. 文档定位

本文档定义远程赛车输入控制系统中**执行端（Executor）**的完整技术设计。

执行端是系统中的**实际输入层**，负责将前端发送的控制状态（ControlResultState）转换为**宿主操作系统可见的真实键盘与真实手柄输入**。

本文档重点描述：

- 执行端运行环境与平台约束
- 键盘与手柄输出的**具体技术路线**
- 所依赖的系统组件、驱动与 Node.js 库
- 各技术方案的能力边界与冻结结论

本文档**不定义**：

- 前端布局系统（UI / Operation / Mapping）
- 控制语义生成或冲突裁决
- 布局编辑器能力
- 通信协议字段细节（由通信协议文档定义）

---

## 2. 执行端在系统中的角色（冻结）

### 2.1 角色定义

执行端在系统中的角色是：

> **控制结果执行器（Control Result Executor）**

其职责是：

> 将前端生成的 **ControlResultState（控制状态快照）**  
> 映射为宿主操作系统可见的输入设备状态。

---

### 2.2 职责边界（冻结）

#### 执行端必须负责

- 接收并校验 ControlResultState
- 将控制状态映射为：
    - 键盘输入
    - 手柄输入
- 维持状态驱动的持续输入语义
- 在断连、超时、异常时**独立清零**
- 返回 ACK 用于 RTT 与延迟观测

#### 执行端不得负责

- 不得理解 UI / Operation / Mapping 语义
- 不得修改控制状态内容
- 不得引入脚本或 DSL
- 不得决定控制是否启用
- 不得承担布局或语义逻辑

---

## 3. 平台与运行环境约束（冻结）

### 3.1 宿主平台

- **操作系统：Windows**
- **目标程序：Windows 游戏**
    - 可能运行于 Wine / Proton 环境
    - 但输入必须落到 Windows 输入子系统

### 3.2 执行端运行时

- **Node.js**
- 允许使用 native addon
- 允许依赖系统级驱动（仅限手柄）

---

## 4. 输入与输出契约（执行端视角）

### 4.1 输入

- WebSocket 接收 ControlResultState
- ControlResultState 为**完整状态快照**
- 缺失 KeyboardState / GamepadState 等价于零状态

### 4.2 输出

- 输出为宿主系统可见的：
    - 键盘输入
    - 手柄输入
- 输出语义为**状态维持**，不是事件播放

---

## 5. 手柄输出实现（最终冻结方案）

### 5.1 技术路线选择（冻结）

| 项目 | 选择 |
|---|---|
| 虚拟手柄驱动 | **ViGEmBus** |
| Node.js 绑定库 | **`vigemclient`（node-ViGEmClient）** |
| 呈现设备类型 | **Xbox 360 控制器（XInput）** |

### 5.2 方案说明

- ViGEmBus 在系统中创建一个**真实的虚拟手柄设备**
- 游戏通过 XInput / HID 看到的是“真实手柄”
- `vigemclient` 作为 Node.js 用户态接口：
    - 创建虚拟控制器
    - 设置轴、按钮、扳机状态
    - 提交整帧状态

### 5.3 依赖与部署约束（冻结）

- **必须安装 ViGEmBus 驱动**
- 需要管理员权限完成驱动安装
- `vigemclient` 为 native addon：
    - 需要 Windows 编译工具链
- 执行端启动前必须确保驱动可用

### 5.4 能力边界

- 支持多轴、多按钮、扳机模拟量
- 支持 125Hz 及以上状态更新
- 不依赖窗口焦点
- 不受大多数游戏输入限制

---

## 6. 键盘输出实现（当前阶段冻结方案）

### 6.1 技术路线选择（冻结）

> **当前阶段（Executor v1.x），键盘输出仅采用用户态键盘输入注入方案（路线 A）。**

- **不引入虚拟 HID 键盘驱动**
- **不实现内核态键盘设备**

### 6.2 具体技术方案

- 使用 **Windows 用户态输入注入 API**
- Node.js 侧通过现成库调用系统输入接口

#### 推荐依赖（冻结）

- **`keysender`**（或等价能力库）

### 6.3 技术特性

- 生成标准键盘按键按下 / 释放事件
- 对系统表现为普通键盘输入
- 支持多按键同时按下
- 与状态驱动模型兼容

### 6.4 能力边界与风险声明（冻结）

执行端**不保证**：

- 所有游戏在以下场景下接受该输入：
    - Raw Input 强依赖
    - 反作弊系统拦截
    - 高权限 / UAC 隔离环境

若目标程序拒绝该输入：

- 视为**系统外部约束**
- 不构成执行端实现缺陷

该边界与需求文档 §9.2 完全一致。

---

## 7. 键盘与手柄方案对比（冻结说明）

| 项目 | 键盘（当前） | 手柄 |
|---|---|---|
| 技术层级 | 用户态注入 | 内核驱动 |
| 依赖 | Node.js 库 | 系统驱动 + Node.js |
| 兼容性 | 中等 | 高 |
| 是否最终形态 | ❌（阶段性） | ✅ |

---

## 8. 路线 B（虚拟 HID 键盘）的状态声明

### 8.1 明确排除（冻结）

以下内容**不属于当前阶段技术设计范围**：

- 虚拟 HID 键盘驱动
- 内核态键盘设备模拟
- Raw Input 级别键盘等价性保证

### 8.2 未来升级路径（仅声明）

- 路线 B 仅作为未来阶段的**可选增强能力**
- 是否引入取决于：
    - 实际游戏兼容性反馈
    - 是否值得承担驱动级复杂度
- 不构成当前阶段承诺

---

## 9. 模块与依赖关系总结

### 9.1 Node.js 侧核心依赖

| 功能 | 依赖 |
|---|---|
| WebSocket 通信 | ws / 等价库 |
| 手柄输出 | vigemclient |
| 键盘输出 | keysender |
| 定时调度 | Node.js timer / 高精度调度 |

### 9.2 系统级依赖

- ViGEmBus 驱动（必须）
- Windows 输入子系统

---

## 10. 当前阶段结论（冻结）

执行端在 v1.x 阶段被明确冻结为：

- **实际输入映射层**
- **状态驱动执行器**
- **手柄：最终技术方案**
- **键盘：阶段性用户态注入方案**
- **安全回退优先于输入完整性**

---

## 11. 文档状态

**Executor Technical Design v1.2 · 冻结版**

---

### 工程结论（最终）

> **这份文档已经明确回答了三个问题：**
>
> 1. 执行端输出的是什么层级的真实输入
> 2. 使用什么技术与库实现
> 3. 哪些能力是当前阶段明确不做的
>
> 执行端现在可以在不引入额外不确定性的前提下直接实现。

---

如果你愿意，下一步可以非常自然地进入：

- **执行端 Node.js 代码结构与 Adapter 实现**
- **通信协议 Schema 冻结**
- **执行端集成测试设计（重点测清零与异常）**

你现在这套文档已经是**工程级可交付状态**了。
