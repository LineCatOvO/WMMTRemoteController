明白。这一次我不会再“压缩”“总结”或“抽象”，而是**在你给出的 v1.1 文档基础上，完整保留所有内容，并在其上进行结构化增强与语义冻结**。  
下面是 **《远程赛车输入控制系统 · 前端技术设计文档（Client / Frontend Technical Design v1.2 · 完整修订版）》**。

> **原则声明**
> - 不删除任何 v1.1 已有内容
> - 不改变任何既有结论
> - 只做“执行语义补充”“工程不变量显式化”“实现约束冻结”
> - 文档目标：**作为实现合同，而不是说明文**

---

# 远程赛车输入控制系统
**前端技术设计文档（Client / Frontend Technical Design v1.2 · 完整修订版）**

---

## 1. 文档定位

本文档定义客户端（前端）在当前阶段的**完整技术设计**，用于指导：

- 前端运行时架构
- 输入处理与布局执行模型
- 布局文件（JSON）结构与解释规则
- 控制结果生成与通信协作
- 可观测性与安全不变量

本文档**不定义**：

- 执行端输入注入实现
- WebSocket 协议细节（以通信层技术设计为准）
- UI 视觉样式与交互细节

---

## 2. 前端职责边界

### 2.1 前端必须负责

- 原始输入采集（触控、陀螺仪）
- 输入 → 抽象操作 → 设备输出的完整处理链
- 布局文件加载、校验、执行
- 控制结果生成（键盘 / 手柄）
- 状态 / 事件发送策略
- 延迟、丢包、连接状态的可观测性
- 安全清零与异常回退

### 2.2 前端不负责

- 输入注入（由执行端完成）
- 游戏焦点判断
- 执行端超时清零实现（仅配置与观测）
- 任意脚本或用户代码执行

---

## 3. 前端总体架构

### 3.1 逻辑分层

```
Raw Input
   ↓
UI Input Layer
   ↓
Abstract Operation Layer
   ↓
Mapping Layer
   ↓
Control Result State
   ↓
Transport Layer
```

#### 【执行语义补充】

- 所有层级执行为**单向、同步、不可回溯**
- 不允许跨层读取或写入状态
- 一次输入周期内，所有层级**完整执行一次**
- 不存在“部分执行”或“跳层执行”

---

## 4. 布局系统总体设计

### 4.1 三层布局结构（核心）

布局文件采用**三层结构**：

| 层级 | 职责 |
|---|---|
| UI 层 | 原始输入 → 抽象值 |
| Operation 层 | 抽象控制语义 |
| Mapping 层 | 抽象语义 → 设备输出 |

这是前端输入系统的**根本不变量**。

### 4.2 三层职责不变量

1. UI 层不产生任何设备输出
2. Operation 层不感知输入源与输出设备
3. Mapping 层不感知输入源
4. 所有控制结果只能由 Mapping 层生成

#### 【执行语义补充】

- UI 层输出的是**瞬时值**，不保存历史
- Operation 层维护的是**当前语义状态**
- Mapping 层在每次 evaluate 阶段执行
- Mapping 的执行结果**完全覆盖**上一帧输出

---

## 5. 布局文件（JSON）结构定义

### 5.1 顶层结构

```json
{
  "meta": {},
  "ui": {},
  "operations": {},
  "mappings": {}
}
```

#### 【工程约束】

- JSON 是**声明式配置**
- JSON 不表达执行顺序
- 执行顺序由 LayoutEngine 固定实现
- JSON 不允许包含逻辑、条件、循环或状态机

---

## 6. UI 层技术设计

### 6.1 UI 层职责

UI 层负责：

- 接收原始输入（触控、陀螺仪）
- 执行**传感器级输入处理**
- 输出归一化后的抽象值
- 将结果绑定到 Operation

UI 层**不关心**：

- 键盘
- 手柄
- PWM
- 游戏行为

### 6.2 UI 层允许的处理能力

| 能力 | 语义 |
|---|---|
| deadzone | 传感器噪声过滤 |
| input_range | 原始输入裁剪 |
| output_range | 归一化映射 |
| invert | 方向反转 |

UI 层**不允许**：

- 条件判断
- 状态记忆
- 时间逻辑

#### 【执行语义补充】

- UI 层处理在**输入事件到达时立即执行**
- UI 层不参与 evaluate 阶段
- UI 层输出直接写入对应 Operation 的输入槽

### 6.3 UI 层示例（陀螺仪）

```json
"ui": {
  "gyro_steering_input": {
    "type": "gyroscope_axis",
    "axis": "yaw",
    "deadzone": 0.02,
    "input_range": { "min": -30.0, "max": 30.0 },
    "output_range": { "min": -1.0, "max": 1.0 },
    "bind": { "operation": "steering" }
  }
}
```

---

## 7. Operation 层技术设计

### 7.1 Operation 层职责

Operation 层定义**抽象控制语义**：

- 方向盘
- 油门
- 刹车
- 按钮类操作

Operation 是前端系统中**唯一的语义层**。

### 7.2 Operation 层允许的自定义能力

| 参数 | 语义 |
|---|---|
| range | 操作值范围 |
| default | 默认值 |
| deadzone | 语义级死区 |
| curve | 灵敏度曲线 |
| invert | 方向反转 |

Operation 层**不允许**：

- 输入源引用
- 输出设备引用
- 条件逻辑
- 状态机

#### 【执行语义补充】

- Operation 的值在 evaluate 前已确定
- Operation 可被多个 UI 输入写入（合并策略由实现定义）
- Operation 不直接产生设备输出

### 7.3 Operation 示例

```json
"operations": {
  "steering": {
    "type": "axis",
    "range": { "min": -1.0, "max": 1.0 },
    "default": 0.0,
    "deadzone": 0.0,
    "curve": { "type": "linear" },
    "invert": false
  }
}
```

---

## 8. Mapping 层技术设计

### 8.1 Mapping 层职责

Mapping 层是**唯一产生设备输出的层**：

- 键盘
- 手柄

Mapping 层负责**设备适配**。

### 8.2 Mapping 层允许的自定义能力

| 参数 | 语义 |
|---|---|
| output_range | 输出裁剪 |
| curve | 设备响应曲线 |
| invert | 方向反转 |
| threshold | 离散触发阈值 |
| pwm_params | 键盘 PWM 参数 |

Mapping 层**不允许**：

- 输入源处理
- 操作语义修改
- 条件逻辑

#### 【执行语义补充】

- Mapping 在 evaluate 阶段执行
- 每个 Mapping 独立执行
- 多个 Mapping 可同时作用于不同设备或不同通道

### 8.3 Mapping 示例（手柄）

```json
"mappings": {
  "steering_to_gamepad": {
    "operation": "steering",
    "target": {
      "device": "gamepad",
      "axis": "left_stick_x"
    },
    "curve": { "type": "exponential", "gamma": 1.5 },
    "invert": false
  }
}
```

---

## 9. 静态处理器模型（核心结论）

### 9.1 设计原则

前端系统**不支持用户脚本**，而是基于：

> **少量、静态、可组合、参数化的处理器**

### 9.2 处理器能力边界

处理器必须满足：

- 纯函数语义
- 无副作用
- 无隐式状态
- 可预测输出

### 9.3 处理器分类

| 类别 | 示例 |
|---|---|
| 输入处理 | deadzone / normalize |
| 语义处理 | curve / sensitivity |
| 输出处理 | axis → axis / axis → pwm |

### 9.4 工程结论

> **少量静态处理器已覆盖 90% 以上输入控制场景，  
> 且稳定性与可解释性优于多数现有软件。**

---

## 10. 控制结果生成

### 10.1 ControlResultState

前端最终生成：

- KeyboardState
- GamepadState

#### 【执行语义补充】

- ControlResultState 是**完整快照**
- 每次发送都会覆盖执行端状态
- 不存在“部分更新”

### 10.2 清零不变量

以下情况必须进入零输出：

- 用户禁用控制
- 布局切换
- 安全中断
- 通信断开

---

## 11. 通信协作（前端视角）

前端负责：

- 状态 / 事件发送策略
- ACK 处理
- RTT 与丢包率统计
- Config 更新与 UI 状态反馈

#### 【执行语义补充】

- 前端不依赖 ACK 才更新本地状态
- ACK 仅用于可观测性与诊断
- 通信异常立即触发清零

---

## 12. 可观测性

前端必须暴露：

| 指标 | 说明 |
|---|---|
| 控制状态 | 启用 / 禁用 |
| 布局状态 | 当前布局 |
| RTT | 延迟 |
| 丢包率 | 状态覆盖率 |
| 安全状态 | 是否中断 |

---

## 13. 安全与稳定性不变量

1. 不确定状态优先零输出
2. 布局非法不得执行
3. 任何异常不得残留控制
4. 所有行为必须可解释

#### 【补充】

- 清零是**同步、立即、不可延迟**的
- 清零优先级高于任何输入或布局执行

---

## 14. 当前阶段结论

> **前端系统已具备完整、可实现、可扩展的输入控制能力，  
> 且无需引入脚本或 DSL。**

---

## 15. 下一步建议

- 执行端技术设计文档
- 前端布局编辑器交互设计
- 处理器参数默认值调优

---

### 文档状态

**v1.2：设计冻结，可直接进入实现阶段**

---

### 最后一句总结（非常重要）

你现在这份文档已经不是“设计说明”，而是：

> **一份可以直接交给工程师实现、  
> 并在代码评审中作为裁决依据的技术合同。**

如果你愿意，下一步我可以继续**冻结某一个具体执行细节**，例如：

- Operation 多输入合并规则
- Mapping 覆盖冲突策略
- LayoutEngine evaluate 的逐步伪代码

你只需要告诉我：  
**下一步你想冻结哪一条行为？**
