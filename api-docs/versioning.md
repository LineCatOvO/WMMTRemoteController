# 版本与兼容策略

## 1. 版本控制概述

Input Script Runtime 系统采用严格的版本控制策略，确保系统各组件之间的兼容性，同时支持持续演进和功能扩展。版本控制涵盖了 Runtime 本身、WebSocket 协议、Script API 和 Profile 格式等多个方面。

## 2. 版本号格式

系统采用**语义化版本控制（Semantic Versioning）**，版本号格式为：

```
MAJOR.MINOR.PATCH
```

### 2.1 版本号含义

| 组件 | 含义 | 示例 |
|------|------|------|
| **MAJOR** | 不兼容的 API 变更 | 1.0.0 → 2.0.0 |
| **MINOR** | 向下兼容的功能性新增 | 1.0.0 → 1.1.0 |
| **PATCH** | 向下兼容的问题修正 | 1.0.0 → 1.0.1 |

### 2.2 版本号使用规则

- **MAJOR**：当进行不兼容的 API 变更、协议格式改变或架构重大调整时递增
- **MINOR**：当添加新功能、扩展 API 或增加可选字段时递增
- **PATCH**：当修复错误、优化性能或改进稳定性时递增
- 版本号从 1.0.0 开始，不使用 0.x.x 的开发版本

## 3. 兼容策略

### 3.1 向后兼容（Backward Compatibility）

**定义**：新版本 Runtime 能够兼容旧版本的 Profile、配置和客户端

**保证范围**：
- ✅ MINOR 和 PATCH 版本保证向后兼容
- ❌ MAJOR 版本可能破坏向后兼容

**兼容内容**：
- Profile 格式和脚本 API
- 配置文件格式
- WebSocket 协议
- 输入数据格式

### 3.2 向前兼容（Forward Compatibility）

**定义**：旧版本 Runtime 能够部分兼容新版本的 Profile 和配置

**保证范围**：
- ⚠️ 有限的向前兼容支持
- 新版本 Profile 可能包含旧版本不支持的功能

**处理方式**：
- 旧版本 Runtime 会忽略不认识的字段
- 对于必填的新字段，会使用默认值
- 不支持的功能会优雅降级

## 4. 组件版本管理

### 4.1 Runtime 版本

- **定义**：表示整个 Runtime 系统的版本
- **存储位置**：在应用的 build.gradle 文件中定义
- **获取方式**：通过 Runtime API 或系统属性获取
- **示例**：`runtime.version()` → "1.2.3"

### 4.2 WebSocket 协议版本

- **定义**：表示 WebSocket 消息格式的版本
- **存储位置**：在 asyncapi.yaml 文件中定义
- **传输方式**：每个 InputFrame 消息中包含 `version` 字段
- **示例**：`{ "type": "input_frame", "version": "1.0", ... }`

### 4.3 Script API 版本

- **定义**：表示提供给 JavaScript 脚本的 API 版本
- **存储位置**：在 runtime 代码中定义
- **使用方式**：Profile 中的 `apiVersion` 字段指定兼容的 API 版本
- **示例**：`profile.json` 中的 `"apiVersion": "1.0"`

### 4.4 Profile 版本

- **定义**：表示单个 Profile 的版本
- **存储位置**：在 Profile 的 `profile.json` 文件中定义
- **使用方式**：用于 Profile 更新和版本管理
- **示例**：`profile.json` 中的 `"version": "1.0.0"`

## 5. 版本检查机制

### 5.1 启动时检查

1. **Runtime 启动**：检查配置文件的版本兼容性
2. **Profile 加载**：
   - 验证 Profile 的 `apiVersion` 与当前 Runtime 兼容
   - 检查 Profile 的 `compatibility` 字段
3. **WebSocket 连接**：验证服务器支持的协议版本

### 5.2 运行时检查

1. **API 调用**：检查脚本调用的 API 是否在当前版本中可用
2. **配置更新**：验证更新的配置是否与当前版本兼容
3. **Profile 切换**：在切换 Profile 时重新验证兼容性

### 5.3 版本不兼容处理

| 场景 | 处理方式 |
|------|----------|
| **Profile API 版本不兼容** | 拒绝加载，切换到默认 Profile |
| **配置格式不兼容** | 使用默认配置，记录警告日志 |
| **WebSocket 协议不兼容** | 断开连接，显示版本不兼容错误 |
| **脚本调用了不存在的 API** | 记录错误，返回默认值或抛出异常 |

## 6. 版本迁移策略

### 6.1 从旧版本升级

**自动迁移**：
- 配置文件：自动将旧格式转换为新格式
- Profile：自动更新兼容的字段和设置

**手动迁移**：
- 对于不兼容的 Profile，提供迁移工具和指南
- 对于自定义脚本，提供 API 变更列表和迁移示例

### 6.2 版本降级

**支持范围**：
- 仅支持降级到相同 MAJOR 版本的旧版本
- 不支持跨 MAJOR 版本降级

**处理方式**：
- 自动检测降级情况
- 验证配置和 Profile 与目标版本兼容
- 对于不兼容的内容，使用默认值或提示用户

## 7. 废弃政策

### 7.1 废弃流程

1. **公告**：在 MINOR 版本中宣布废弃计划
2. **标记**：在文档和日志中标记废弃的 API 或功能
3. **警告**：运行时对使用废弃功能的代码发出警告
4. **移除**：在下次 MAJOR 版本中移除废弃的功能

### 7.2 废弃周期

- **最小废弃周期**：6 个月或 2 个 MINOR 版本
- **最大废弃周期**：12 个月或 4 个 MINOR 版本
- **例外情况**：安全漏洞修复可能会缩短废弃周期

### 7.3 废弃通知方式

- **日志警告**：在运行时记录废弃警告
- **文档标记**：在 API 文档中标记废弃状态
- **发布说明**：在版本发布说明中列出废弃的功能
- **Profile 验证**：在 Profile 验证时检测使用了废弃 API

## 8. 版本发布流程

### 8.1 版本规划

1. **功能规划**：确定新版本要包含的功能和改进
2. **兼容性评估**：评估对现有系统的影响
3. **版本号确定**：根据功能和兼容性确定新版本号

### 8.2 开发与测试

1. **代码开发**：实现新功能和修复
2. **兼容性测试**：测试与旧版本的兼容性
3. **回归测试**：确保现有功能正常工作
4. **性能测试**：验证性能符合要求

### 8.3 发布准备

1. **更新文档**：更新 API 文档、使用指南和示例
2. **生成 asyncapi.yaml**：更新 WebSocket 协议定义
3. **编写发布说明**：记录版本变更、新功能和废弃内容
4. **构建发布包**：生成可发布的应用包

### 8.4 发布与部署

1. **内部发布**：在内部团队中进行测试
2. **公开发布**：发布到应用商店或下载渠道
3. **通知用户**：通过应用内通知或邮件通知用户更新
4. **监控反馈**：监控用户反馈和系统日志，及时处理问题

## 9. 版本管理最佳实践

### 9.1 对于 Runtime 开发者

- **严格遵循语义化版本控制**：确保版本号反映了变更的性质
- **维护完整的发布说明**：详细记录每个版本的变更内容
- **提供迁移指南**：对于不兼容的变更，提供清晰的迁移步骤
- **测试兼容性**：在发布前测试与旧版本的兼容性
- **保持 API 稳定性**：避免频繁变更核心 API

### 9.2 对于 Profile 开发者

- **明确指定 apiVersion**：在 profile.json 中指定兼容的 API 版本
- **使用稳定的 API**：优先使用标记为稳定的 API，避免使用实验性 API
- **处理废弃警告**：及时更新使用了废弃 API 的代码
- **测试多个版本**：在多个 Runtime 版本上测试 Profile
- **遵循最小依赖原则**：只依赖必要的 API 和功能

## 10. 版本兼容性示例

### 10.1 兼容的版本组合

| Runtime 版本 | Profile apiVersion | 兼容状态 | 说明 |
|--------------|--------------------|----------|------|
| 1.2.3 | 1.0 | ✅ 兼容 | 新版本 Runtime 兼容旧版本 API |
| 1.2.3 | 1.2 | ✅ 兼容 | 相同 MAJOR 版本，完全兼容 |
| 1.2.3 | 1.3 | ⚠️ 部分兼容 | 旧版本 Runtime 忽略不认识的 API |
| 2.0.0 | 1.2 | ❌ 不兼容 | MAJOR 版本变更，API 可能不兼容 |

### 10.2 WebSocket 协议版本处理

```json
// 旧版本协议 (1.0)
{
  "type": "input_frame",
  "version": "1.0",
  "frameId": 123,
  "keyboard": ["W"],
  "mouse": { "x": 0.5, "y": 0.5 },
  "joystick": { "x": 0, "y": -1 }
}

// 新版本协议 (1.1) - 向后兼容
{
  "type": "input_frame",
  "version": "1.1",
  "frameId": 123,
  "keyboard": ["W"],
  "mouse": { "x": 0.5, "y": 0.5 },
  "joystick": { "x": 0, "y": -1 },
  "gyroscope": { "pitch": 0, "roll": 0, "yaw": 0 }  // 新增字段，可选
}
```

### 10.3 Profile 兼容性示例

```json
// 旧版本 Profile (apiVersion: 1.0)
{
  "name": "old_profile",
  "version": "1.0.0",
  "apiVersion": "1.0",
  "settings": {
    "sensitivity": 1.0
  }
}

// 新版本 Profile (apiVersion: 1.1)
{
  "name": "new_profile",
  "version": "1.0.0",
  "apiVersion": "1.1",
  "category": "racing",  // 新增字段
  "settings": {
    "sensitivity": 1.0,
    "gyroEnabled": true   // 新增设置项
  }
}
```

## 11. 版本管理工具

### 11.1 版本检查工具

- **Profile 验证工具**：验证 Profile 与指定 Runtime 版本的兼容性
- **API 兼容性检查器**：检查脚本是否使用了不兼容的 API
- **协议验证工具**：验证 WebSocket 消息是否符合协议规范

### 11.2 迁移工具

- **Profile 迁移工具**：将旧版本 Profile 转换为新版本格式
- **配置迁移工具**：自动更新配置文件格式
- **脚本更新工具**：自动替换使用了废弃 API 的代码

## 12. 常见版本问题处理

### 12.1 Profile 加载失败

**问题**：Profile 无法加载，提示版本不兼容

**解决步骤**：
1. 检查 Profile 的 `apiVersion` 字段
2. 确认当前 Runtime 版本
3. 如果是 MAJOR 版本不兼容，需要更新 Profile
4. 如果是 MINOR 版本，检查是否使用了不兼容的 API
5. 使用迁移工具更新 Profile

### 12.2 WebSocket 连接失败

**问题**：WebSocket 连接失败，提示协议版本不兼容

**解决步骤**：
1. 检查客户端和服务器的协议版本
2. 确认服务器支持客户端的协议版本
3. 如果是 MAJOR 版本不兼容，需要升级客户端或服务器
4. 检查网络连接和服务器状态

### 12.3 脚本执行错误

**问题**：脚本执行时出错，提示函数未定义

**解决步骤**：
1. 检查脚本中调用的 API 是否在当前版本中存在
2. 查看 API 文档，确认正确的 API 名称和参数
3. 如果是 API 已废弃，使用替代方案
4. 更新 Profile 的 `apiVersion` 字段

## 13. 结论

严格的版本控制和兼容策略是 Input Script Runtime 系统稳定运行和持续演进的基础。通过遵循语义化版本控制、明确的兼容保证和完善的迁移机制，系统能够在不断添加新功能的同时，保持与现有系统的兼容性。

开发者在使用和扩展系统时，应该充分了解版本控制策略，遵循最佳实践，确保系统各组件之间的兼容性，减少版本升级带来的问题和风险。

随着系统的发展，版本控制策略也会不断完善和调整，以适应新的需求和挑战。系统会定期评估和更新兼容策略，确保在灵活性和稳定性之间取得平衡。